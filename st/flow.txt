I have developed (wrote all tcl/shell scripts for automation), over the years, complete, automated block level physical implementation and verification design flows and used/deployed them successfully for production tapeouts:

* Cadence (Genus/Innovus) based RTL→GDSII flow: once
* Cadence (Encounter/Innovus) based netlist→GDSII flow: 4 times
* Magma (Blastfusion) based netlist→GDSII flow: twice
* Synopsys (Primetime) STA flow: 3 times
* Cadence (Tempus) STA flow: 2 times
* RC extraction (STaR, Assura, QRC, Quantus): 4 times
* LVS/DRC/ERC/ANT (Mentor Calibre, Cadence Assura/PVS using TSMC decks): 4 times
* Cadence LEC (Conformal): 3 times

* Low Power Verification(Cadence Conformal-LP using CPF),
    Synopsys LEC (Formality),
    Sequence (Cooltime) STA flow, 
    Synopsys (Pathmill or Nanotime) STA flow
    Circuit Semantics (Dynacore) + Pearl STA flow
    Synopsys (PTPX) Power Analysis,
    Cadence semi-custom (Assura) RC extraction,
    Sequence (Coolpower) EM/IR,
    Apache (Redhawk/Seascape) EM/IR, 
    Cadence (Abgen) LEF generation: At least once
 
Few were built around EDA vendors' reference flows.

Though not primarily a programmer/coder, I have, over 30 years, programmed in 
many langauages but please don't give me a pop quiz. I have coded minimum spanning
tree, shortest path graph algorithms, AVL tree and other searching/sorting/hashing algorithms 
and implemented a minimal LISP interpreter in Pascal that implemented recursive "defun" functions,
all within the first few months of touching a computer keyboard for the first time. This was in 
1990, when I also wrote my first "App" in Turbo-pascal that had a DOS based GUI and would generate
various patterns of audible morse code for practicing.

TCL, Python, C-shell, Perl, C, R, Pascal : Thousands of lines  of code
Swift, MATLAB, Scala, SKILL, Objective-C, Java : Hundreds of lines of code

See some of my code at: https://github.com/swiftgurmeet

